#include "libprism.h"

#if 0
#define _VRAM_OFFSET(n) ((n)<<3)
#define _VRAM_PTR ((u16*)0x06000000)
#define _VRAM_CD_MAIN_BG_0x6000000 (1 | _VRAM_OFFSET(0))
#define _VRAM_CD_MAIN_BG_0x6020000 (1 | _VRAM_OFFSET(1))
#define _VRAM_CD_ARM7_0x6000000 (2 | _VRAM_OFFSET(0))
#define _VRAM_CD_ARM7_0x6020000 (2 | _VRAM_OFFSET(1))
#endif

unsigned char ndshead[512]={
  0x2e,0x00,0x00,0xea,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x23,0x23,0x23,0x23,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,
  0x00,0x02,0x00,0x00,0x00,0x00,0x38,0x02,0x00,0x00,0x38,0x02,0x00,0xa0,0x00,0x00,
  0x00,0xa2,0x00,0x00,0x00,0xd8,0x3a,0x02,0x00,0xd8,0x3a,0x02,0x00,0x19,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xff,0x7f,0x7f,0x00,0xff,0x1f,0x3f,0x20,0x00,0x00,0x00,0x00,0x00,0x00,0x1e,0x05,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0xbe,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x53,0x52,0x41,0x4d,0x5f,0x56,0x31,0x31,0x30,0x00,0x00,0x00,0x50,0x41,0x53,0x53,
  0x30,0x31,0x96,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0xc8,0x60,0x4f,0xe2,0x01,0x70,0x8f,0xe2,0x17,0xff,0x2f,0xe1,0x12,0x4f,0x11,0x48,
  0x12,0x4c,0x20,0x60,0x64,0x60,0x7c,0x62,0x30,0x1c,0x39,0x1c,0x10,0x4a,0x00,0xf0,
  0x14,0xf8,0x30,0x6a,0x80,0x19,0xb1,0x6a,0xf2,0x6a,0x00,0xf0,0x0b,0xf8,0x30,0x6b,
  0x80,0x19,0xb1,0x6b,0xf2,0x6b,0x00,0xf0,0x08,0xf8,0x70,0x6a,0x77,0x6b,0x07,0x4c,
  0x60,0x60,0x38,0x47,0x07,0x4b,0xd2,0x18,0x9a,0x43,0x07,0x4b,0x92,0x08,0xd2,0x18,
  0x0c,0xdf,0xf7,0x46,0x04,0xf0,0x1f,0xe5,0x00,0xfe,0x7f,0x02,0xf0,0xff,0x7f,0x02,
  0xf0,0x01,0x00,0x00,0xff,0x01,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x1a,0x9e,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

static inline void _dmaFillWords(const void* src, void* dest, uint32 size) {
	DMA_SRC(3)  = (uint32)src;
	DMA_DEST(3) = (uint32)dest;
	DMA_CR(3)   = DMA_COPY_WORDS | DMA_SRC_FIX | (size>>2);
	while(DMA_CR(3) & DMA_BUSY);
}

/*
static void resetMemory1_ARM9(){
	//REG_EXMEMCNT|=1 << 7;

	//(*(vu32*)0x00803FFC) = 0;   //IRQ_HANDLER ARM9 version
	//(*(vu32*)0x00803FF8) = ~0;  //VBLANK_INTR_WAIT_FLAGS ARM9 version
}
*/

static void resetMemory2_ARM9(){
 	register int i;
  
	//clear out ARM9 DMA channels
	for (i=0; i<4; i++) {
		DMA_CR(i) = 0;
		DMA_SRC(i) = 0;
		DMA_DEST(i) = 0;
		TIMER_CR(i) = 0;
		TIMER_DATA(i) = 0;
	}

	VRAM_CR = 0x80808080;
	(*(vu32*)0x02fFFE04) = 0;   // temporary variable
	BG_PALETTE[0] = 0xFFFF;
	_dmaFillWords((void*)0x02fFFE04, BG_PALETTE+1, (2*1024)-2);
	_dmaFillWords((void*)0x02fFFE04, OAM,     2*1024);
	_dmaFillWords((void*)0x02fFFE04, (void*)0x04000000, 0x56);  //clear main display registers
	_dmaFillWords((void*)0x02fFFE04, (void*)0x04001000, 0x56);  //clear sub  display registers
	_dmaFillWords((void*)0x02fFFE04, VRAM,  656*1024);
	
	REG_DISPSTAT=0;
	videoSetMode(0);
	videoSetModeSub(0);
	VRAM_A_CR = 0;
	VRAM_B_CR = 0;
	VRAM_C_CR = 0;
	VRAM_D_CR = 0;
	VRAM_E_CR = 0;
	VRAM_F_CR = 0;
	VRAM_G_CR = 0;
	VRAM_H_CR = 0;
	VRAM_I_CR = 0;
	VRAM_CR   = 0x00000000;
	REG_POWERCNT = 0x820F;
	//REG_EXMEMCNT = 0xe880;

	//set shared ram to ARM7
	WRAM_CR = 0x03;
}

//static void __attribute__ ((long_call)) (*lp_resetMemory2_ARM9) (void) =resetMemory2_ARM9;

void bootMoonlight(u32 BootAddress){
 	disc_unmount();
  
	//VRAM_C_CR = VRAM_ENABLE | _VRAM_CD_MAIN_BG_0x6000000;
	//VRAM_D_CR = VRAM_ENABLE | _VRAM_CD_MAIN_BG_0x6020000;
  
	//_consolePrint("resetMemory1_ARM9\n");
	//resetMemory1_ARM9();
	_consolePrint("resetMemory2_ARM9\n");
	resetMemory2_ARM9();

	//IPCZ->bootaddress=0;
	IPCZ->bootaddress=BootAddress;
	NotifyARM7(ResetMoonlight);
	REG_IME = 0;
	REG_IE  = 0;
	REG_IF  = ~0;

	_consolePrintf("Reset to 0x%08x\n",BootAddress);
	IC_InvalidateAll();
	DC_FlushAll();
	DC_InvalidateAll();
  
	//VRAM_C_CR = VRAM_ENABLE | _VRAM_CD_ARM7_0x6000000;
	//VRAM_D_CR = VRAM_ENABLE | _VRAM_CD_ARM7_0x6020000;
	//*((vu32*)0x02fFFE04) = (u32)0xE59FF018;  // ldr pc, 0x02fFFE24
	//*((vu32*)0x02fFFE24) = (u32)0x02fFFE04;  // Set ARM9 Loop address
	*memUncachedAddr(0x02fFFFFC)=0;
	*memUncachedAddr(0x02fFFE04)=0xE59FF018;
	*memUncachedAddr(0x02fFFE24)=(u32)memUncachedAddr(0x02fFFE04);
	//IPCZ->bootaddress=BootAddress;
	swiSoftReset();  // Reset
	_consolePrint("Failed.\n");while(1);
}

bool BootDSBooter(const char *pFilename){
	struct stat st;
	u32 FileSize;
	u8 *pFileBuf;
	u8 head[512],dec[512];

	u8 *pA=NULL,*p7=NULL,*p9=NULL;
	u32 l7,l9,a7,a9,pad7,pad9;

	FILE *FileHandle=fopen(pFilename,"rb");
	fread(head,1,512,FileHandle);
  
	if(FileHandle==NULL)
		{_consolePrintf("Can not open NDS file %s.\n",pFilename);return false;}

	fstat(fileno(FileHandle),&st);
	FileSize=st.st_size;
  
	if(FileSize==0)
		{_consolePrintf("Can not open NDS file %s.\n",pFilename);return false;}

	_consolePrint("MainRam loader X with m3make preparing.\n");

	//building header...
	_consolePrint("Decrypting... ");
	{
		int i=0,j;
		for(;i<0x100;i++){
			for(j=0xa0;j<0xa8;j++)
				dec[j]=head[j]^i;
			if(!memcmp(dec+0xa0,"DSBooter",8))
				{_consolePrintf("key = 0x%02x\n",i);break;}
		}
		if(i==0x100){_consolePrint("Cannot decode or not DSBooter\n");return false;}
		for(j=0x000;j<0x200;j++)
			head[j]=head[j]^i;
	}
	pA=head+0xc8;
	_consolePrintf("p9=0x%08x\n",(p9=pA+read32(pA+0x00))-head);
	_consolePrintf("l9=0x%08x\n",l9=read32(pA+0x08));
	_consolePrintf("a9=0x%08x\n",a9=read32(pA+0x04));
	_consolePrintf("p7=0x%08x\n",(p7=pA+read32(pA+0x0c)+0x0c)-head);
	_consolePrintf("l7=0x%08x\n",l7=read32(pA+0x14));
	_consolePrintf("a7=0x%08x\n",a7=read32(pA+0x10));
	pad9=0x100-(l9&0xff);if(pad9==0x100)pad9=0;
	pad7=0x100-(l7&0xff);if(pad7==0x100)pad7=0;

	//writing loader to memory...
	pFileBuf=(u8*)(0x02000000+2*1024*1024);
	memcpy(pFileBuf,ndshead,512);
	write32(pFileBuf+0x24,a9);
	write32(pFileBuf+0x28,a9);
	write32(pFileBuf+0x2c,l9/*+pad9*/);
	write32(pFileBuf+0x30,l9+pad9+0x200);
	write32(pFileBuf+0x34,a7);
	write32(pFileBuf+0x38,a7);
	write32(pFileBuf+0x3c,l7/*+pad7*/);
	write32(pFileBuf+0x80,0x200+l9+pad9+l7+pad7);
	write16(pFileBuf+0x15e,swiCRC16(0xffff,pFileBuf,0x15e));
	fseek(FileHandle,p9-head,SEEK_SET);
	fread(pFileBuf+0x200,1,l9,FileHandle);
	fseek(FileHandle,p7-head,SEEK_SET);
	fread(pFileBuf+0x200+l9+pad9,1,l7,FileHandle);
	fclose(FileHandle);

	//FileHandle=fopen("/loader.bin","wb");
	//fwrite(pFileBuf,1,0x200+l9+pad9+l7+pad7,FileHandle);
	//fclose(FileHandle);
  
	_consolePrint("Rebooting...\n");
	installargv(pFileBuf,(char*)0x02fff400,pFilename);
	bootMoonlight((u32)pFileBuf+0xc0);
	return true;
}

/*
bool BootDSBooterRaw(const char *pFilename){ //Not working...
	struct stat st;
	u32 FileSize;
	u8 *pFileBuf;
	u8 head[512],dec[512];

	FILE *FileHandle=fopen(pFilename,"rb");
	fread(head,1,512,FileHandle);
  
	if(FileHandle==NULL)
		{_consolePrintf("Can not open NDS file %s.\n",pFilename);return false;}

	fstat(fileno(FileHandle),&st);
	FileSize=st.st_size;
  
	if(FileSize==0)
		{_consolePrintf("Can not open NDS file %s.\n",pFilename);return false;}

	_consolePrint("MainRam loader X with m3make preparing.\n");

	//building header...
	_consolePrint("Decrypting... ");
	{
		int i=0,j;
		for(;i<0x100;i++){
			for(j=0xa0;j<0xa8;j++)
				dec[j]=head[j]^i;
			if(!memcmp(dec+0xa0,"DSBooter",8))
				{_consolePrintf("key = 0x%02x\n",i);break;}
		}
		if(i==0x100){_consolePrint("Cannot decode or not DSBooter\n");return false;}
		for(j=0x000;j<0x200;j++)
			head[j]=head[j]^i;
	}
  
	_consolePrint("Rebooting...\n");
	installargv(pFileBuf,(char*)0x02fff400,pFilename);
	bootMoonlight((u32)pFileBuf+0xc0);
	return true;
}
*/

/*
void R4_00(){
	u8 command[8];
	u32 ret;

	command[7] = 0x0;
	command[6] = 0;
	command[5] = 0;
	command[4] = 0;
	command[3] = 0;
	command[2] = 0;
	command[1] = 0;
	command[0] = 0;
	cardPolledTransfer(0xa7586000, &ret, 1, command);
	//return ret;
}
*/

bool BootR4Menu(const char *pFilename){
	struct stat st;
	if(stat(pFilename,&st)){_consolePrintf("Can not stat R4Menu %s.\n",pFilename);return false;}
	//if(st.st_size>0x001ff000){
	//	_consolePrint("Filesize too big. Halt.\n");return false;
	//}
	u32 addr=(u32)getFATEntryAddress(pFilename);
	if(!addr){_consolePrintf("Error occurred in getting sector of %s.\n",pFilename);return false;}
	R4_ReadCardInfo();
	R4_SendMap(addr&0xfffffffe);
	//R4_00();
	R4_ReadCardInfo();

	u8* pFileBuf=(u8*)(0x02000000+2*1024*1024);
	R4_ReadMenu(0,(u32*)(pFileBuf+0),128);
	u32 arm7end=read32(pFileBuf+0x30)+read32(pFileBuf+0x3c);
	int pos;
	for(pos=512;pos<arm7end;pos+=512)R4_ReadMenu(pos,(u32*)(pFileBuf+pos),128);
	dldi2(pFileBuf,arm7end,0,NULL);
	bootMoonlight((u32)pFileBuf+0xc0);
	return true;
}

bool BootNDSROM2(const char *pFilename,const int bypassYSMenu,const char* dumpname){
	struct stat st;
	u32 FileSize;
	u8 *pFileBuf;
	FILE *FileHandle=fopen(pFilename,"rb");
  
	if(FileHandle==NULL)
		{_consolePrintf("Can not open NDS file %s.\n",pFilename);return false;}

	fstat(fileno(FileHandle),&st);
	FileSize=st.st_size;
  
	if(FileSize<512)
		{_consolePrintf("Can not open NDS file %s.\n",pFilename);return false;}

	_consolePrint("MainRam loader X preparing.\n");
	_consolePrint("Trying to load file\n");

	pFileBuf=(u8*)(0x02000000+2*1024*1024);
	fread(pFileBuf,1,512,FileHandle);
	u32 arm7end=read32(pFileBuf+0x30)+read32(pFileBuf+0x3c);
	if(arm7end>0x001ff000){
		_consolePrint("Filesize too big. Falling back to bootlib.\n");
		fclose(FileHandle);
#ifdef LIBFAT
		return runNdsFile(pFilename);
#else
		return runNdsFileViaStub(pFilename);
#endif
	}
	fread(pFileBuf+512,1,align4(arm7end)-512,FileHandle);
	fclose(FileHandle);

	_consolePrint("Applying DLDI...\n");
	dldi2(pFileBuf,arm7end,bypassYSMenu,dumpname);
	_consolePrint("Rebooting...\n");
	installargv(pFileBuf,(char*)0x02fff400,pFilename);
	bootMoonlight((u32)pFileBuf+0xc0);
	return true;
}

bool BootNDSROM(const char *pFilename){return BootNDSROM2(pFilename,0,NULL);}
